> Docker 包括三个基本概念
- 镜像(image)
- 容器(container)
- 仓库(repository)

> Docker 镜像
- 操作系统分为内核和用户空间
- 对于Linux而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持
- Docker 镜像(image) 相当于一个 root 文件系统
- Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等)。镜像不包含任何动态数据，其内容在构建之后也不会被改变
- 镜像是容器的基础，每次执行 docker run 的时候都会指定哪个镜像作为容器运行的基础

> Docker 容器
- 镜像(image)和容器(container)的关系，就像是面向对象程序设计中的类和实例一样
- 镜像是静态的定义，容器是镜像运行时的实体
- 容器可以被创建、启动、停止、删除、暂停等
- 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行与属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、自己的进程空间，甚至自己的用户ID空间
- 每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层
- 容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。
- 容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷(Volume)、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发送读写，其性能和稳定性更高
- 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行后，数据去不会丢失


> 理解镜像的构建
```
docker run --name webserver -d -p 80:80 nginx
```
- 使用nginx镜像定制一个容器，命名为 webserver，并且映射了 80 端口
- 当我们运行一个容器的时候(如果不使用卷的话)，我们做的任何文件修改都会被记录与容器存储层里
- docker commit 命令，可以将容器的存储层保存下来成为镜像,缺点：使镜像臃肿
```
docker commit [选项]<容器ID或容器名>[<仓库名>[:<标签>]]
```
查看镜像内的历史记录
```
docker history nginx
```
> Dockerfile 定制镜
- Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction),每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建
- Union FS 是有最大层数限制的，比如AUFS，曾经是最大不得超过42层，现在是最大不得超过127层
```
FROM <镜像名称>  //FROM 就是指定基础镜像，因此一个Dockerfile中 FROM 是必备的指令，并且必须是第一条指令
RUN <命令>  //shell格式 : RUN 指令是用来执行命令行命令的
RUN ["可执行文件","参数1","参数2"] // exec 格式
```

```
FROM scratch //特殊镜像，名为scratch，这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像
```
> 镜像构建
- 工作原理：Docker在运行时分为Docker引擎(也就是服务端守护进程)和客户端工具。构建镜像时，其实并非在本地创建，而是在服务端，也就是Docker引擎中构建的;用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传个Docker引擎。这样Docker引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件
```
docker build [选项] <上下文路径/URL/-> //docker build 命令最后有一个. 表示当前目录
```

> COPY 复制文件
- COPY 指令将从构建上下文目录中 <源路径> 的文件/目录复制到新的一层的镜像内的 <目标路径> 位置
- <源路径> 可以是多个甚至可以用通配符
```
COPY <源路径> ... <目标路径>
COPY ["<源路径1>",..."<目标路径>"]
```

> CMD 容器启动文件
- CMD 指令就是用于指定默认的容器主进程的启动命令的
```
shell 格式: CMD <命令>
exec  格式: CMD ["可执行文件","参数1","参数2"...]
```
> ENTRYPOINT 入口点
- 需要通过docker run 的参数 --entrypoint 来指定
- 当指定了 ENTRYPOINT 后，CMD的含义就发生了改变，不再是直接的运行其命令，而是将CMD的内容作为参数传递给ENTRYPOINT执行，换句话说实际执行时，将变为: <ENTRYPOIINT>"<CMD>"

> ENV 设置环境变量
- 定义了环境变量，那么在后续的指令中，就可以使用这个环境变量
```
ENV <key> <value>
ENV <key1>=<value1> <key2>=<value2> ...
```
> ARG 构建参数
- 构建参数和ENV的效果一样，都是用来是设置环境变量。所不同的是，ARG所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的
- Dockerfile 中的ARG指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令docker build 中用 --build-arg <参数名>=<值> 来覆盖
```
ARG <参数名>[=<默认值>]
```

> VOLUME 定义匿名卷
- VLOUME /data
- /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化
```
VOLUME ["<路径1>","<路径2>"...]
VOLUME <路径>
```

> EXPOSE 声明端口
- EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务
- 在Dockerfile中写入这样的声明有两个好处: 一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射;另一个是在运行时使用随机端口映射时，也就是docker run -p 时,会自动随机映射 EXPOSE 的端口
- 在运行时使用 -p <宿主端口>:<容器端口> ，-p 是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问
```
EXPOSOE <端口1>[<端口2> ...]
```

> WORKDIR 指定工作目录
- 使用WORKDIR 指令可以来指定工作目录,以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR会帮你创建
```
WORKDIR <工作目录路径>
```

> USER 指定当前用户
```
USER <用户名>
```